/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewChild, Input, ElementRef } from '@angular/core';
/**
 * The Intersection Observer API provides a way to asynchronously observe changes in the
 * intersection of a target element with an ancestor element or with a top-level document’s
 * viewport. -MDN
 *
 *
 * The actual detection implementation doesn’t run on the main thread. However, the callback for
 * when an intersection has been triggered does run on the main thread so keep it light!
 *
 * The rootMargin option takes in a string that conforms to the regular CSS margin rule.
 * Here we are telling to increase the bottom dectin boundry by 200px. Meaning the
 * intersection callback will be triggered once the user arrivers at the bottom of the root
 * element +200px (default is 0).
 *
 */
export class NgxLazyImagesComponent {
    constructor() {
        this.alt = 'Lazy Loaded Image';
        this.defaultConfig = {
            rootMargin: '0px 0px',
        };
        this.config = this.defaultConfig;
        this.visibilityHidden = { visibility: 'hidden' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initPlaceholder();
        this.height = this.height || 0;
        this.width = this.width || 0;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.observer = this.initIntersectionObserver();
        this.observer.observe(this.lazyImageEl.nativeElement);
    }
    /**
     * @return {?}
     */
    initIntersectionObserver() {
        return new IntersectionObserver((/**
         * @param {?} entries
         * @return {?}
         */
        entries => {
            this.onIntersection(entries);
        }), Object.assign({}, this.config));
    }
    // Callback is executed on the main thread, it should operate as quickly as possible.
    /**
     * @param {?} entries
     * @param {?=} observer
     * @return {?}
     */
    onIntersection(entries, observer) {
        entries.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        entry => {
            this.imageLoader(entry);
        }));
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    imageLoader(entry) {
        const { isIntersecting, target } = entry;
        try {
            /** @type {?} */
            const image = new Image();
            if (!this.src) {
                console.error('Lazy image element returned empty image source', target);
                return;
            }
            if (isIntersecting) {
                this.fetchImageMeta(image, this.src)
                    .then((/**
                 * @return {?}
                 */
                () => {
                    this.height = this.height || image.height;
                    this.width = this.width || image.width;
                    this.lazyImageEl.nativeElement.src = image.src;
                    this.isImgLoaded = true;
                    this.observer.disconnect();
                }))
                    .catch((/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    console.error(`Fetching image meta data failed with ${target}`, err);
                }));
            }
        }
        catch (exception) {
            console.error(`Image loader failed with ${target}`, exception);
        }
    }
    /**
     * @param {?} image
     * @param {?} src
     * @return {?}
     */
    fetchImageMeta(image, src) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} error
         * @return {?}
         */
        (resolve, error) => {
            image.src = src;
            image.onload = resolve; // eslint-disable-line no-param-reassign
            image.onerror = error; // eslint-disable-line no-param-reassign
        }));
    }
    /**
     * @return {?}
     */
    initPlaceholder() {
        this.defaultPlaceholder = {
            'position': 'relative',
            'width': '100%',
            'height': '100%',
            'background-color': '#3A6073',
            'background': this.placeholder ? this.placeholder : 'linear-gradient(to right, #3A6073, #16222A)',
            /* blur filters */
            '-webkit-filter': 'blur(5px)',
            '-o-filter': 'blur(5px)',
            'filter': 'blur(5px)',
        };
    }
}
NgxLazyImagesComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-lazy-images',
                template: "<div>\n  <div [style.width]=\"width + 'px'\" [style.height]=\"height + 'px'\" [ngStyle]=\"isImgLoaded ? null : defaultPlaceholder\">\n    <img\n      #lazyImage\n      [alt]=\"alt\"\n      [height]=\"height\"\n      [width]=\"width\"\n      [ngStyle]=\"isImgLoaded ? null : visibilityHidden\"\n    />\n  </div>\n</div>\n"
            }] }
];
/** @nocollapse */
NgxLazyImagesComponent.ctorParameters = () => [];
NgxLazyImagesComponent.propDecorators = {
    lazyImageEl: [{ type: ViewChild, args: ['lazyImage',] }],
    height: [{ type: Input }],
    width: [{ type: Input }],
    src: [{ type: Input }],
    alt: [{ type: Input }],
    placeholder: [{ type: Input }],
    config: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NgxLazyImagesComponent.prototype.lazyImageEl;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.height;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.width;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.src;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.alt;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.placeholder;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.defaultConfig;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.config;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.observer;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.isImgLoaded;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.defaultPlaceholder;
    /** @type {?} */
    NgxLazyImagesComponent.prototype.visibilityHidden;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWxhenktaW1hZ2VzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1sYXp5LWxvYWRpbmctaW1hZ2VzLyIsInNvdXJjZXMiOlsibGliL25neC1sYXp5LWltYWdlcy9uZ3gtbGF6eS1pbWFnZXMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxLQUFLLEVBRUwsVUFBVSxFQUNYLE1BQU0sZUFBZSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FBc0J2QixNQUFNLE9BQU8sc0JBQXNCO0lBd0JqQztRQWhCUyxRQUFHLEdBQUcsbUJBQW1CLENBQUM7UUFHbkMsa0JBQWEsR0FBRztZQUNkLFVBQVUsRUFBRSxTQUFTO1NBQ3RCLENBQUM7UUFFTyxXQUFNLEdBQTZCLElBQUksQ0FBQyxhQUFhLENBQUM7UUFPL0QscUJBQWdCLEdBQUcsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLENBQUM7SUFFNUIsQ0FBQzs7OztJQUVqQixRQUFRO1FBQ04sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztJQUMvQixDQUFDOzs7O0lBRUQsZUFBZTtRQUNiLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDaEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN4RCxDQUFDOzs7O0lBRUQsd0JBQXdCO1FBQ3RCLE9BQU8sSUFBSSxvQkFBb0I7Ozs7UUFDN0IsT0FBTyxDQUFDLEVBQUU7WUFDUixJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9CLENBQUMscUJBRUksSUFBSSxDQUFDLE1BQU0sRUFFakIsQ0FBQztJQUNKLENBQUM7Ozs7Ozs7SUFHRCxjQUFjLENBQUMsT0FBb0MsRUFBRSxRQUFjO1FBQ2pFLE9BQU8sQ0FBQyxPQUFPOzs7O1FBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQixDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUM7Ozs7O0lBRUQsV0FBVyxDQUFDLEtBQWdDO2NBQ3BDLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxHQUFHLEtBQUs7UUFFeEMsSUFBSTs7a0JBQ0ksS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFO1lBRXpCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNiLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0RBQWdELEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQ3hFLE9BQU87YUFDUjtZQUVELElBQUksY0FBYyxFQUFFO2dCQUNsQixJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDO3FCQUNqQyxJQUFJOzs7Z0JBQUMsR0FBRyxFQUFFO29CQUNULElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDO29CQUMxQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQztvQkFDdkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUM7b0JBQy9DLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO29CQUN4QixJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUM3QixDQUFDLEVBQUM7cUJBQ0QsS0FBSzs7OztnQkFBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO29CQUNiLE9BQU8sQ0FBQyxLQUFLLENBQUMsd0NBQXdDLE1BQU0sRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RSxDQUFDLEVBQUMsQ0FBQzthQUNOO1NBQ0Y7UUFBQyxPQUFPLFNBQVMsRUFBRTtZQUNsQixPQUFPLENBQUMsS0FBSyxDQUFDLDRCQUE0QixNQUFNLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUNoRTtJQUNILENBQUM7Ozs7OztJQUVELGNBQWMsQ0FBQyxLQUF1QixFQUFFLEdBQVc7UUFDakQsT0FBTyxJQUFJLE9BQU87Ozs7O1FBQUMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDcEMsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDaEIsS0FBSyxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyx3Q0FBd0M7WUFDaEUsS0FBSyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FBQyx3Q0FBd0M7UUFDakUsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7O0lBRUQsZUFBZTtRQUNiLElBQUksQ0FBQyxrQkFBa0IsR0FBRztZQUN4QixVQUFVLEVBQUUsVUFBVTtZQUN0QixPQUFPLEVBQUUsTUFBTTtZQUNmLFFBQVEsRUFBRSxNQUFNO1lBQ2hCLGtCQUFrQixFQUFFLFNBQVM7WUFDN0IsWUFBWSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLDZDQUE2Qzs7WUFFakcsZ0JBQWdCLEVBQUUsV0FBVztZQUM3QixXQUFXLEVBQUUsV0FBVztZQUN4QixRQUFRLEVBQUUsV0FBVztTQUN0QixDQUFDO0lBQ0osQ0FBQzs7O1lBN0dGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsaUJBQWlCO2dCQUMzQiw0VUFBK0M7YUFFaEQ7Ozs7OzBCQUVFLFNBQVMsU0FBQyxXQUFXO3FCQUdyQixLQUFLO29CQUNMLEtBQUs7a0JBRUwsS0FBSztrQkFDTCxLQUFLOzBCQUNMLEtBQUs7cUJBTUwsS0FBSzs7OztJQWROLDZDQUFnRDs7SUFHaEQsd0NBQXdCOztJQUN4Qix1Q0FBdUI7O0lBRXZCLHFDQUFxQjs7SUFDckIscUNBQW1DOztJQUNuQyw2Q0FBNkI7O0lBRTdCLCtDQUVFOztJQUVGLHdDQUErRDs7SUFFL0QsMENBQStCOztJQUMvQiw2Q0FBcUI7O0lBRXJCLG9EQUF3Qjs7SUFFeEIsa0RBQTRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBWaWV3Q2hpbGQsXG4gIElucHV0LFxuICBBZnRlclZpZXdJbml0LFxuICBFbGVtZW50UmVmLCBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogVGhlIEludGVyc2VjdGlvbiBPYnNlcnZlciBBUEkgcHJvdmlkZXMgYSB3YXkgdG8gYXN5bmNocm9ub3VzbHkgb2JzZXJ2ZSBjaGFuZ2VzIGluIHRoZVxuICogaW50ZXJzZWN0aW9uIG9mIGEgdGFyZ2V0IGVsZW1lbnQgd2l0aCBhbiBhbmNlc3RvciBlbGVtZW50IG9yIHdpdGggYSB0b3AtbGV2ZWwgZG9jdW1lbnTigJlzXG4gKiB2aWV3cG9ydC4gLU1ETlxuICpcbiAqXG4gKiBUaGUgYWN0dWFsIGRldGVjdGlvbiBpbXBsZW1lbnRhdGlvbiBkb2VzbuKAmXQgcnVuIG9uIHRoZSBtYWluIHRocmVhZC4gSG93ZXZlciwgdGhlIGNhbGxiYWNrIGZvclxuICogd2hlbiBhbiBpbnRlcnNlY3Rpb24gaGFzIGJlZW4gdHJpZ2dlcmVkIGRvZXMgcnVuIG9uIHRoZSBtYWluIHRocmVhZCBzbyBrZWVwIGl0IGxpZ2h0IVxuICpcbiAqIFRoZSByb290TWFyZ2luIG9wdGlvbiB0YWtlcyBpbiBhIHN0cmluZyB0aGF0IGNvbmZvcm1zIHRvIHRoZSByZWd1bGFyIENTUyBtYXJnaW4gcnVsZS5cbiAqIEhlcmUgd2UgYXJlIHRlbGxpbmcgdG8gaW5jcmVhc2UgdGhlIGJvdHRvbSBkZWN0aW4gYm91bmRyeSBieSAyMDBweC4gTWVhbmluZyB0aGVcbiAqIGludGVyc2VjdGlvbiBjYWxsYmFjayB3aWxsIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSB1c2VyIGFycml2ZXJzIGF0IHRoZSBib3R0b20gb2YgdGhlIHJvb3RcbiAqIGVsZW1lbnQgKzIwMHB4IChkZWZhdWx0IGlzIDApLlxuICogKi9cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LWxhenktaW1hZ2VzJyxcbiAgdGVtcGxhdGVVcmw6ICcuL25neC1sYXp5LWltYWdlcy5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogW11cbn0pXG5leHBvcnQgY2xhc3MgTmd4TGF6eUltYWdlc0NvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uSW5pdCB7XG4gIEBWaWV3Q2hpbGQoJ2xhenlJbWFnZScpIGxhenlJbWFnZUVsOiBFbGVtZW50UmVmO1xuXG4gIC8vIEltYWdlIE1ldGEgRGF0YVxuICBASW5wdXQoKSBoZWlnaHQ6IG51bWJlcjtcbiAgQElucHV0KCkgd2lkdGg6IG51bWJlcjtcblxuICBASW5wdXQoKSBzcmM6IHN0cmluZztcbiAgQElucHV0KCkgYWx0ID0gJ0xhenkgTG9hZGVkIEltYWdlJztcbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZztcblxuICBkZWZhdWx0Q29uZmlnID0ge1xuICAgIHJvb3RNYXJnaW46ICcwcHggMHB4JyxcbiAgfTtcblxuICBASW5wdXQoKSBjb25maWc6IEludGVyc2VjdGlvbk9ic2VydmVySW5pdCA9IHRoaXMuZGVmYXVsdENvbmZpZztcblxuICBvYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gIGlzSW1nTG9hZGVkOiBib29sZWFuO1xuXG4gIGRlZmF1bHRQbGFjZWhvbGRlcjogYW55O1xuXG4gIHZpc2liaWxpdHlIaWRkZW4gPSB7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH07XG5cbiAgY29uc3RydWN0b3IoKSB7IH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmluaXRQbGFjZWhvbGRlcigpO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCB8fCAwO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB0aGlzLmluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpO1xuICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmxhenlJbWFnZUVsLm5hdGl2ZUVsZW1lbnQpO1xuICB9XG5cbiAgaW5pdEludGVyc2VjdGlvbk9ic2VydmVyKCk6IEludGVyc2VjdGlvbk9ic2VydmVyIHtcbiAgICByZXR1cm4gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgZW50cmllcyA9PiB7XG4gICAgICAgIHRoaXMub25JbnRlcnNlY3Rpb24oZW50cmllcyk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLy8gQ2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gdGhlIG1haW4gdGhyZWFkLCBpdCBzaG91bGQgb3BlcmF0ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuICBvbkludGVyc2VjdGlvbihlbnRyaWVzOiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5W10sIG9ic2VydmVyPzogYW55KSB7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIHRoaXMuaW1hZ2VMb2FkZXIoZW50cnkpO1xuICAgIH0pO1xuICB9XG5cbiAgaW1hZ2VMb2FkZXIoZW50cnk6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpIHtcbiAgICBjb25zdCB7IGlzSW50ZXJzZWN0aW5nLCB0YXJnZXQgfSA9IGVudHJ5O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG5cbiAgICAgIGlmICghdGhpcy5zcmMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTGF6eSBpbWFnZSBlbGVtZW50IHJldHVybmVkIGVtcHR5IGltYWdlIHNvdXJjZScsIHRhcmdldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hJbWFnZU1ldGEoaW1hZ2UsIHRoaXMuc3JjKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmxhenlJbWFnZUVsLm5hdGl2ZUVsZW1lbnQuc3JjID0gaW1hZ2Uuc3JjO1xuICAgICAgICAgICAgdGhpcy5pc0ltZ0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGZXRjaGluZyBpbWFnZSBtZXRhIGRhdGEgZmFpbGVkIHdpdGggJHt0YXJnZXR9YCwgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEltYWdlIGxvYWRlciBmYWlsZWQgd2l0aCAke3RhcmdldH1gLCBleGNlcHRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZldGNoSW1hZ2VNZXRhKGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LCBzcmM6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCBlcnJvcikgPT4ge1xuICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgaW1hZ2Uub25sb2FkID0gcmVzb2x2ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgaW1hZ2Uub25lcnJvciA9IGVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgfSk7XG4gIH1cblxuICBpbml0UGxhY2Vob2xkZXIoKSB7XG4gICAgdGhpcy5kZWZhdWx0UGxhY2Vob2xkZXIgPSB7XG4gICAgICAncG9zaXRpb24nOiAncmVsYXRpdmUnLFxuICAgICAgJ3dpZHRoJzogJzEwMCUnLFxuICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMzQTYwNzMnLFxuICAgICAgJ2JhY2tncm91bmQnOiB0aGlzLnBsYWNlaG9sZGVyID8gdGhpcy5wbGFjZWhvbGRlciA6ICdsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMzQTYwNzMsICMxNjIyMkEpJyxcbiAgICAgIC8qIGJsdXIgZmlsdGVycyAqL1xuICAgICAgJy13ZWJraXQtZmlsdGVyJzogJ2JsdXIoNXB4KScsXG4gICAgICAnLW8tZmlsdGVyJzogJ2JsdXIoNXB4KScsXG4gICAgICAnZmlsdGVyJzogJ2JsdXIoNXB4KScsXG4gICAgfTtcbiAgfVxuXG59XG4iXX0=